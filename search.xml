<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[数据结构与算法系列 - 06 树]]></title>
    <url>%2F2019%2F05%2F13%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%B3%BB%E5%88%97%20-%2006%20%E6%A0%91%2F</url>
    <content type="text"><![CDATA[参考：极客时间树相关知识 二叉树 每个节点最多有两个“叉”，也就是两个子节点，分别是左子节点和右节点 满二叉树：编号 2 的二叉树中，叶子节点全都在最底层，除了叶子节点之外，每个节点都有左右两个子节点，这种二叉树就叫作满二叉树。 完全二叉树：编号 3 的二叉树中，叶子节点都在最底下两层，最后一层的叶子节点都靠左排列，并且除了最后一层，其他层的节点个数都要达到最大。 存储方式链式存储法每个节点有三个字段，其中一个存储数据，另外两个是指向左右子节点的指针。我们只要拎住根节点，就可以通过左右子节点的指针，把整棵树都串起来。 顺序存储法 把根节点存储在下标 i = 1 的位置， 那左子节点存储在下标2 * i = 2 的位置， 右子节点存储在 2 * i + 1= 3 的位置。 以此类推，B 节点的左子节点存储在 2 * i = 2 * 2 = 4 的位置，右子节点存储在 2 * i + 1 = 2 * 2 + 1 = 5 的位置。 遍历方式 遍历的时间复杂度是 O(n)需要理解并能用递归代码来实现 前序遍历对于树中的任意节点来说，先打印这个节点，然后再打印它的左子树，最后打印它的右子树。 中序遍历对于树中的任意节点来说，先打印它的左子树，然后再打印它本身，最后打印它的右子树。 后序遍历对于树中的任意节点来说，先打印它的左子树，然后再打印它的右子树，最后打印这个节点本身。 遍历伪代码1234567891011121314151617181920void preOrder(Node* root) &#123; if (root == null) return; print root // 此处为伪代码，表示打印 root 节点 preOrder(root-&gt;left); preOrder(root-&gt;right);&#125;void inOrder(Node* root) &#123; if (root == null) return; inOrder(root-&gt;left); print root // 此处为伪代码，表示打印 root 节点 inOrder(root-&gt;right);&#125;void postOrder(Node* root) &#123; if (root == null) return; postOrder(root-&gt;left); postOrder(root-&gt;right); print root // 此处为伪代码，表示打印 root 节点&#125; 二叉查找树 定义：二叉查找树要求，在树中的任意一个节点，其左子树中的每个节点的每个节点的值，都要小于这个节点的值，而右子树节点的值都大于这个节点的值。 查找1234567891011121314151617181920212223public class BinarySearchTree &#123; private Node tree; public Node find(int data) &#123; Node p = tree; while (p != null) &#123; if (data &lt; p.data) p = p.left; else if (data &gt; p.data) p = p.right; else return p; &#125; return null; &#125; public static class Node &#123; private int data; private Node left; private Node right; public Node(int data) &#123; this.data = data; &#125; &#125;&#125; 插入1234567891011121314151617181920212223public void insert(int data) &#123; if (tree == null) &#123; tree = new Node(data); return; &#125; Node p = tree; while (p != null) &#123; if (data &gt; p.data) &#123; if (p.right == null) &#123; p.right = new Node(data); return; &#125; p = p.right; &#125; else &#123; // data &lt; p.data if (p.left == null) &#123; p.left = new Node(data); return; &#125; p = p.left; &#125; &#125;&#125; 删除删除操作比较复杂，可以分为三种情况： 要删除的节点没有子节点：我们只需要直接将父节点中，指向要删除节点的指针置为 null。比如图中的删除节点 55。 要删除的节点只有一个子节点（只有左子节点或者右子节点）：我们只需要更新父节点中，指向要删除节点的指针，让它指向要删除节点的子节点就可以了。比如图中的删除节点 13。 要删除的节点有两个子节点：需要找到这个节点的右子树中的最小节点，把它替换到要删除的节点上。然后再删除掉这个最小节点，因为最小节点肯定没有左子节点（如果有左子结点，那就不是最小节点了），所以，我们可以应用上面两条规则来删除这个最小节点。比如图中的删除节点 18。]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java常用命令]]></title>
    <url>%2F2019%2F05%2F08%2FJava%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[监测垃圾回收情况jstat -gcutil -h10 &lt;pid&gt; 3s 1000 启动并查看日志bin/startup.sh ; tail -f logs/catalina.out 关闭匹配关键字的进程kill -9 $(ps aux |grep online | grep java | awk &#39;{print $2}&#39;)]]></content>
  </entry>
  <entry>
    <title><![CDATA[Alibaba Sentinel源码分析]]></title>
    <url>%2F2019%2F04%2F15%2FApache%20Sentinel%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[关于Alibaba Sentinel是什么、以及具有哪些特性、怎么使用（Sentinel Demo 集锦）等等，可以查看官方github wiki说明，这里不详细展开。 整体时序图 初始化InitFunc框架提供InitFunc接口，用于实现首次执行时的初始化操作，因为是通过SPI机制进行加载，所有用户层可以自扩展自己的初始化操作，同时提供@InitOrder注解，用户控制执行顺序（越小越先执行）。 CommandCenterInitFunc原理：通过SPI机制加载CommandCenter插件，唯一实现类SimpleHttpCommandCenter。功能：启动client内置的http服务（socket实现），用于和sentinel-dashboard服务进行通讯 HeartbeatSenderInitFunc原理：通过SPI机制加载HeartbeatSender插件，唯一实现类SimpleHttpHeartbeatSender。功能：定时向sentinel-dashboard（uri=/registry/machine）发送心跳信息。多个控制台地址格式：ip1:port1,ip2:port2… 定义资源执行逻辑框架定义资源使用的是SphU.entry(…)函数，内部具体执行逻辑如下： 具体插槽功能见官方说明：Sentinel工作主流程 监控信息获取 节点数据结构 滑动时间窗口 ArrayMetric 监控信息存储及查询 MetricTimerListener MetricSearcher 规则编排默认编排实现类DefaultSlotChainBuilder1234567891011121314151617public class DefaultSlotChainBuilder implements SlotChainBuilder &#123; @Override public ProcessorSlotChain build() &#123; ProcessorSlotChain chain = new DefaultProcessorSlotChain(); chain.addLast(new NodeSelectorSlot()); chain.addLast(new ClusterBuilderSlot()); chain.addLast(new LogSlot()); chain.addLast(new StatisticSlot()); chain.addLast(new SystemSlot()); chain.addLast(new AuthoritySlot()); chain.addLast(new FlowSlot()); chain.addLast(new DegradeSlot()); return chain; &#125;&#125; 应用可以自定义实现，实现SlotChainBuilder接口并重写build()方法。 监控规则 流控规则FlowSlot基于QPS/并发数的流量控制官方文档-流量控制 QPS流量控制 同一个资源可以创建多条限流规则。FlowSlot 会对该资源的所有限流规则依次遍历，直到有规则触发限流或者所有规则遍历完毕。 直接拒绝默认的流量控制方式，当QPS超过任意规则的阈值后，新的请求就会被立即拒绝，拒绝方式为抛出FlowException。 Warm Up预热/冷启动方式。通过”冷启动”，让通过的流量缓慢增加，在一定时间内逐渐增加到阈值上限，给冷系统一个预热的时间，避免冷系统被压垮。 匀速排队让请求以均匀的速度通过，对应的是漏桶算法。这种方式主要用于处理间隔性突发的流量，例如消息队列。 并发线程数流量控制 并发线程数限流不负责创建和管理线程池，而是简单统计当前请求上下文的线程数目，如果超出阈值，新的请求会被立即拒绝，效果类似于信号量隔离 基于调用关系的流量控制根据调用方限流 页面位置：流控规则-&gt;新增流控规则-&gt;流控模式-&gt;直接 流控规则中的 limitApp 字段用于根据调用来源进行流量控制。同一个资源名可以配置多条规则，规则的生效顺序为：{some_origin_name} &gt; other &gt; default 注意：limitApp为空时则不执行流控校验 根据调用链路入口限流：链路限流 页面位置：流控规则-&gt;新增流控规则-&gt;流控模式-&gt;链路 具有关系的资源流量控制：关联流量控制 页面位置：流控规则-&gt;新增流控规则-&gt;流控模式-&gt;关联 降级规则DegradeSlot官方文档-熔断降级 平均响应时间 并不是资源平均相应时间大于设定rt时立马执行降级，而是在时间窗口1s内（StatisticNode.avgRt()）发生5（DegradeRule.RT_MAX_EXCEED_N）次，才会执行降级。 Sentinel 默认统计的 RT 上限是 4900 ms，超出此阈值的都会算作 4900 ms，若需要变更此上限可以通过启动配置项 -Dcsp.sentinel.statistic.max.rt=xxx 来配置。 12345678910111213141516171819202122232425public class DegradeRule extends AbstractRule &#123; ...... @Override public boolean passCheck(Context context, DefaultNode node, int acquireCount, Object... args) &#123; ...... if (grade == RuleConstant.DEGRADE_GRADE_RT) &#123; double rt = clusterNode.avgRt(); if (rt &lt; this.count) &#123; passCount.set(0); return true; &#125; // Sentinel will degrade the service only if count exceeds. if (passCount.incrementAndGet() &lt; RT_MAX_EXCEED_N) &#123; return true; &#125; &#125; ...... // 更新降级标记位，并启动重置线程，在设定时间窗口内关闭降级开关 if (cut.compareAndSet(false, true)) &#123; ResetTask resetTask = new ResetTask(this); pool.schedule(resetTask, timeWindow, TimeUnit.SECONDS); &#125; ......&#125; 12345678910111213141516public class StatisticSlot extends AbstractLinkedProcessorSlot&lt;DefaultNode&gt; &#123; ...... @Override public void exit(Context context, ResourceWrapper resourceWrapper, int count, Object... args) &#123; ...... if (context.getCurEntry().getError() == null) &#123; // Calculate response time (max RT is TIME_DROP_VALVE). long rt = TimeUtil.currentTimeMillis() - context.getCurEntry().getCreateTime(); if (rt &gt; Constants.TIME_DROP_VALVE) &#123; rt = Constants.TIME_DROP_VALVE; &#125; ...... &#125; ...... &#125;&#125; 异常比例 异常比率的阈值范围是 [0.0, 1.0]，代表 0% - 100% 时间窗口单位为1秒 异常数资源近 1 分钟的异常数目超过阈值之后会进行熔断。 系统规则SystemSlot官方文档-系统自适应限流Sentinel有定时机制，每隔1s检查当前系统负载情况12345678910111213141516171819public class SystemRuleManager &#123; ...... // sentinel-dashboard配置项变更监听 private final static SystemPropertyListener listener = new SystemPropertyListener(); private static SentinelProperty&lt;List&lt;SystemRule&gt;&gt; currentProperty = new DynamicSentinelProperty&lt;List&lt;SystemRule&gt;&gt;(); @SuppressWarnings(&quot;PMD.ThreadPoolCreationRule&quot;) private final static ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(1, new NamedThreadFactory(&quot;sentinel-system-status-record-task&quot;, true)); static &#123; checkSystemStatus.set(false); // 定时监听系统负载 statusListener = new SystemStatusListener(); scheduler.scheduleAtFixedRate(statusListener, 5, 1, TimeUnit.SECONDS); currentProperty.addListener(listener); &#125; ......&#125; LoadRT线程数入口 QPS授权规则AuthoritySlot官方文档-黑白名单控制 白名单黑名单热点规则ParamFlowSlot官方文档-热点参数限流需要结合public static Entry entry(Method method, EntryType type, int count, Object... args) throws BlockException等含有Object... args参数的方法使用。主要用于热点数据限流。 集群流控ClusterBuilderSlot]]></content>
      <categories>
        <category>Sentinel</category>
      </categories>
      <tags>
        <tag>限流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java核心技术]]></title>
    <url>%2F2019%2F03%2F11%2FJava%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%2F</url>
    <content type="text"><![CDATA[SPI机制 SPI全称Service Provider Interface，是Java提供的一套用来被第三方实现或者扩展的API，它可以用来启用框架扩展和替换组件。 基于接口的编程＋策略模式＋配置文件 组合实现的动态加载机制。 需要遵循如下约定： 当服务提供者提供了接口的一种具体实现后，在jar包的META-INF/services目录下创建一个以“接口全限定名”为命名的文件，内容为实现类的全限定名； 接口实现类所在的jar包放在主程序的classpath中； 主程序通过java.util.ServiceLoder动态装载实现模块，它通过扫描META-INF/services目录下的配置文件找到实现类的全限定名，把类加载到JVM； SPI的实现类必须携带一个不带参数的构造方法； 反射 反射机制是 Java 语言提供的一种基础功能，赋予程序在 运行时 自省（introspect，官方用语）的能力。通过反射我们可以直接操作类或者对象，比如获取某个对象的类定义，获取类声明的属性和方法，调用方法或者构造对象，甚至可以 运行时 修改类定义。 在运行时能判断任意一个对象所属的类。 在运行时能构造任意一个类的对象。 在运行时判断任意一个类所具有的成员变量和方法。 在运行时调用任意一个对象的方法。 应用场景反射技术常用在各类通用框架开发中。因为为了保证框架的通用性，需要根据配置文件加载不同的对象或类，并调用不同的方法，这个时候就会用到反射——运行时动态加载需要加载的对象。 特点由于反射会额外消耗一定的系统资源，因此如果不需要动态地创建一个对象，那么就不需要用反射。另外，反射调用方法时可以忽略权限检查，因此可能会破坏封装性而导致安全问题。 动态代理 动态代理是一种方便运行时动态构建代理、动态处理代理方法调用的机制，很多场景都是利用类似机制做到的，比如用来包装 RPC 调用、面向切面的编程（AOP）。 (动态)代理模式主要涉及三个要素 抽象类接口 被代理类（具体实现抽象接口的类） 动态代理类：实际调用被代理类的方法和属性的类 实现方式实现动态代理的方式很多，比如 JDK 自身提供的动态代理，就是主要利用了反射机制。还有其他的实现方式，比如利用字节码操作机制，类似 ASM、CGLIB（基于 ASM）、Javassist 等。举例，常可采用的JDK提供的动态代理接口InvocationHandler来实现动态代理类。其中invoke方法是该接口定义必须实现的，它完成对真实方法的调用。通过InvocationHandler接口，所有方法都由该Handler来进行处理，即所有被代理的方法都由InvocationHandler接管实际的处理任务。此外，我们常可以在invoke方法实现中增加自定义的逻辑实现，实现对被代理类的业务逻辑无侵入 动态代理：JDK动态代理和CGLIB代理的区别？JDK动态代理只能对实现了接口的类生成代理，而不能针对类，CGLIB是针对类实现代理，主要是对指定的类生成一个子类，覆盖其中的方法（继承）。 JDK Proxy 的优势： 最小化依赖关系，减少依赖意味着简化开发和维护，JDK 本身的支持，可能比 cglib 更加可靠。 平滑进行 JDK 版本升级，而字节码类库通常需要进行更新以保证在新版 Java 上能够使用。 代码实现简单。 基于类似 cglib 框架的优势： 有的时候调用目标可能不便实现额外接口，从某种角度看，限定调用者实现接口是有些侵入性的实践，类似 cglib 动态代理就没有这种限制。 只操作我们关心的类，而不必为其他相关类增加工作量。 高性能。 Spring在选择用JDK还是CGLiB的依据是什么？ 当Bean实现接口时，Spring就会用JDK的动态代理 当Bean没有实现接口时，Spring使用CGlib是实现 可以强制使用CGlib（在spring配置中加入&lt;aop:aspectj-autoproxy proxy-target-class=”true”/&gt;） 自动装箱、拆箱 自动装箱实际上算是一种 语法糖。什么是语法糖？可以简单理解为 Java 平台为我们自动进行了一些转换，保证不同的写法在运行时等价，它们发生在编译阶段，也就是生成的字节码是一致的。 在Java SE5之前，如果要生成一个数值为10的Integer对象，必须这样进行：1Integer i = new Integer(10); 而在从Java SE5开始就提供了自动装箱的特性，如果要生成一个数值为10的Integer对象，只需要这样就可以了：1Integer i = 10; 装箱：自动将基本数据类型转换为包装器类型（通过调用包装器的valueOf方法实现） 拆箱：自动将包装器类型转换为基本数据类型（通过调用包装器的 xxxValue方法实现的，xxx代表对应的基本数据类型） Integer i = new Integer(xxx)和Integer i =xxx;这两种方式的区别： 第一种方式不会触发自动装箱的过程；而第二种方式会触发； 在执行效率和资源占用上的区别。第二种方式的执行效率和资源占用在一般性情况下要优于第一种情况（注意这并不是绝对的） 注意：当 “==”运算符的两个操作数都是 包装器类型的引用，则是比较指向的是否是同一个对象，而如果其中有一个操作数是表达式（即包含算术运算）则比较的是数值（即会触发自动拆箱的过程）1234567891011121314151617181920public class Main &#123; public static void main(String[] args) &#123; Integer a = 1; Integer b = 2; Integer c = 3; Integer d = 3; Integer e = 321; Integer f = 321; Long g = 3L; Long h = 2L; System.out.println(c==d); //true Integer缓存了-128~127，在该范围内返回的是同一个实例 System.out.println(e==f); //false 超过了缓存范围，不同实例 System.out.println(c==(a+b)); //true 包含算术运算，会触发自动拆箱过程（会调用intValue方法），因此它们比较的是数值是否相等 System.out.println(c.equals(a+b)); //true a+b先各自触发自动拆箱过程，再触发自动装箱过程，再进行equals比较 System.out.println(g==(a+b)); //true 同上 System.out.println(g.equals(a+b)); //false a+b最后装箱后是Integer型，Long型equals参数如果是非Long型则直接返回false System.out.println(g.equals(a+h)); //true a+h装箱后是Long型，比较的是数值 &#125;&#125; 扩展Integer缓存机制（-128~127）并不是只有 Integer 才有，同样存在于其他的一些包装类，比如： Boolean，缓存了 true/false 对应实例，确切说，只会返回两个常量实例 Boolean.TRUE/FALSE。 Short，同样是缓存了 -128 到 127 之间的数值。 Byte，数值有限，所以全部都被缓存。 Character，缓存范围’\u0000’ 到 ‘\u007F’。]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构与算法系列 - 07 排序算法]]></title>
    <url>%2F2019%2F02%2F20%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%B3%BB%E5%88%97%20-%2007%20%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[基础术语说明 稳定：如果a原本在b前面，而a=b，排序之后a仍然在b的前面； 不稳定：如果a原本在b的前面，而a=b，排序之后a可能会出现在b的后面； 内排序：所有排序操作都在内存中完成； 外排序：由于数据太大，因此把数据放在磁盘中，而排序通过磁盘和内存的数据传输才能进行； 时间复杂度： 一个算法执行所耗费的时间。 空间复杂度：运行完一个程序所需内存的大小。 算法复杂度 名词解释： n: 数据规模 k: “桶”的个数 In-place: 占用常数内存，不占用额外内存 Out-place: 占用额外内存 冒泡排序（Bubble Sort）描述 比较相邻的元素。如果第一个比第二个大，就交换它们两个； 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数； 针对所有的元素重复以上的步骤，除了最后一个； 重复步骤1~3，直到排序完成。 选择排序（Selection Sort）表现最稳定的排序算法之一，因为无论什么数据进去都是O(n²)的时间复杂度，所以用到它的时候，数据规模越小越好。 选择排序(Selection-sort)是一种简单直观的排序算法。它的工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。 描述 初始状态：无序区为R[1..n]，有序区为空； 第i趟排序(i=1,2,3…n-1)开始时，当前有序区和无序区分别为R[1..i-1]和R(i..n）。该趟排序从当前无序区中-选出关键字最小的记录 R[k]，将它与无序区的第1个记录R交换，使R[1..i]和R[i+1..n)分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区； n-1趟结束，数组有序化了。代码12345678910111213141516171819public void selectSort() &#123; if (data == null || data.length == 0) &#123; return; &#125; // 外层循环：对未排序空间逐步迭代 for (int i = 0; i &lt; data.length; i++) &#123; int minIndex = i; // 内层循环：在未排序空间查找最小元素索引 for (int j = i; j &lt; data.length; j++) &#123; if (data[minIndex] &gt; data[j]) &#123; minIndex = j; &#125; &#125; int tmp = data[i]; data[i] = data[minIndex]; data[minIndex] = tmp; &#125; System.out.println(Arrays.deepToString(data));&#125; 插入排序（Insertion Sort）工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序在实现上，通常采用in-place排序（即只需用到O(1)的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。 描述 从第一个元素开始，该元素可以认为已经被排序； 取出下一个元素，在已经排序的元素序列中从后向前扫描； 如果该元素（已排序）大于新元素，将该元素移到下一位置； 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置； 将新元素插入到该位置后； 重复步骤2~5。代码123456789101112131415/** * 插入排序 */public Integer[] insertionSort(Integer[] data) &#123; for (int i = 0; i &lt; data.length - 1; i++) &#123; int preIndex = i; int value = data[i + 1]; while (preIndex &gt;= 0 &amp;&amp; value &lt; data[preIndex]) &#123; data[preIndex + 1] = data[preIndex]; preIndex--; &#125; data[preIndex + 1] = value; &#125; return data;&#125; 希尔排序（Shell Sort）希尔排序是希尔（Donald Shell）于1959年提出的一种排序算法。希尔排序也是一种插入排序，它是简单插入排序经过改进之后的一个更高效的版本，也称为缩小增量排序，同时该算法是冲破O(n2）的第一批算法之一。它与插入排序的不同之处在于，它会优先比较距离较远的元素。希尔排序又叫缩小增量排序。 希尔排序是把记录按下表的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止。 我们来看下希尔排序的基本步骤，在此我们选择增量gap=length/2，缩小增量继续以gap = gap/2的方式，这种增量选择我们可以用一个序列来表示，{n/2,(n/2)/2…1}，称为增量序列。希尔排序的增量序列的选择与证明是个数学难题，我们选择的这个增量序列是比较常用的，也是希尔建议的增量，称为希尔增量，但其实这个增量序列不是最优的。此处我们做示例使用希尔增量。 整个待排序的记录序列分割成为若干子序列分别进行直接插入排序 描述 选择一个增量序列t1，t2，…，tk，其中ti&gt;tj，tk=1； 按增量序列个数k，对序列进行k 趟排序； 每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。 代码1234567891011121314151617181920/** * 希尔排序 */public Integer[] shellSort(Integer[] array) &#123; int len = array.length; int temp, gap = len / 2; while (gap &gt; 0) &#123; for (int i = gap; i &lt; len; i++) &#123; temp = array[i]; int preIndex = i - gap; while (preIndex &gt;= 0 &amp;&amp; array[preIndex] &gt; temp) &#123; array[preIndex + gap] = array[preIndex]; preIndex -= gap; &#125; array[preIndex + gap] = temp; &#125; gap /= 2; &#125; return array;&#125; 归并排序（Merge Sort）和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是O(n log n）的时间复杂度。代价是需要额外的内存空间。 归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。归并排序是一种稳定的排序方法。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。 分治算法一般都是用递归来实现的，分治是一种解决问题的处理思想，递归是一种编程技巧 描述 把长度为n的输入序列分成两个长度为n/2的子序列； 对这两个子序列分别采用归并排序； 将两个排序好的子序列合并成一个最终的排序序列。 代码1234567891011121314151617181920212223242526272829303132/** * 归并排序 */public Integer[] mergeSort(Integer[] data) &#123; if (data.length &lt; 2) return data; int mid = data.length / 2; Integer[] left = Arrays.copyOfRange(data, 0, mid); Integer[] right = Arrays.copyOfRange(data, mid, data.length); return merge(mergeSort(left), mergeSort(right));&#125;/** * 归并排序——将两段排序好的数组结合成一个排序数组 * * @param left * @param right * @return */public Integer[] merge(Integer[] left, Integer[] right) &#123; Integer[] result = new Integer[left.length + right.length]; for (int index = 0, i = 0, j = 0; index &lt; result.length; index++) &#123; if (i &gt;= left.length) result[index] = right[j++]; else if (j &gt;= right.length) result[index] = left[i++]; else if (left[i] &gt; right[j]) result[index] = right[j++]; else result[index] = left[i++]; &#125; return result;&#125; 快速排序（Quick Sort）快速排序的基本思想：通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。 思想 从数列中挑出一个元素，称为 “基准”（pivot）； 重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作； 递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/** * 快速排序方法 * * @param array * @param start * @param end * @return */public Integer[] quickSort(Integer[] array, int start, int end) &#123; if (array.length &lt; 1 || start &lt; 0 || end &gt;= array.length || start &gt; end) &#123; return null; &#125; int smallIndex = partition(array, start, end); if (smallIndex &gt; start) &#123; quickSort(array, start, smallIndex - 1); &#125; if (smallIndex &lt; end) &#123; quickSort(array, smallIndex + 1, end); &#125; return array;&#125;/** * 快速排序算法——partition * * @param array * @param start * @param end * @return */public int partition(Integer[] array, int start, int end) &#123; int pivot = (int) (start + Math.random() * (end - start + 1)); int smallIndex = start - 1; swap(array, pivot, end); for (int i = start; i &lt;= end; i++) &#123; if (array[i] &lt;= array[end]) &#123; smallIndex++; if (i &gt; smallIndex) &#123; swap(array, i, smallIndex); &#125; &#125; &#125; return smallIndex;&#125;/** * 交换数组内两个元素 * * @param array * @param i * @param j */public void swap(Integer[] array, int i, int j) &#123; int temp = array[i]; array[i] = array[j]; array[j] = temp;&#125; 堆排序计数排序桶排序基数排序]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[数据结构与算法系列 - 05 队列]]></title>
    <url>%2F2019%2F02%2F18%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%B3%BB%E5%88%97%20-%2005%20%E9%98%9F%E5%88%97%2F</url>
    <content type="text"><![CDATA[参考：09 | 队列：队列在线程池等有限资源池中的应用 队列跟栈一样，也是一种操作受限的线性表数据结构。可以把它想象成排队买票，先来的先买，后来的人只能站末尾，不允许插队。先进者先出，这就是典型的“队列”。 两个基本操作： 入队 enqueue()，放一个数据到队列尾部 出队 dequeue()，从队列头部取一个元素 &#160; &#160;队列的概念很好理解，基本操作也很容易掌握。作为一种非常基础的数据结构，队列的应用也非常广泛，特别是一些具有某些额外特性的队列，比如循环队列、阻塞队列、并发队列。它们在很多偏底层系统、框架、中间件的开发中，起着关键性的作用。比如高性能队列 Disruptor、Linux 环形缓存，都用到了循环并发队列；Java concurrent 并发包利用 ArrayBlockingQueue 来实现公平锁等。 顺序队列和链式队列 &#160; &#160;跟栈一样，队列可以用数组来实现，也可以用链表来实现。用数组实现的栈叫作顺序栈，用链表实现的栈叫作链式栈。同样，用数组实现的队列叫作顺序队列，用链表实现的队列叫作链式队列。 顺序队列12345678910111213141516171819202122232425262728293031323334// 用数组实现的队列public class ArrayQueue &#123; // 数组：items，数组大小：n private String[] items; private int n = 0; // head 表示队头下标，tail 表示队尾下标 private int head = 0; private int tail = 0; // 申请一个大小为 capacity 的数组 public ArrayQueue(int capacity) &#123; items = new String[capacity]; n = capacity; &#125; // 入队 public boolean enqueue(String item) &#123; // 如果 tail == n 表示队列已经满了 if (tail == n) return false; items[tail] = item; ++tail; return true; &#125; // 出队 public String dequeue() &#123; // 如果 head == tail 表示队列为空 if (head == tail) return null; // 为了让其他语言的同学看的更加明确，把 -- 操作放到单独一行来写了 String ret = items[head]; ++head; return ret; &#125;&#125; 对于栈来说，我们只需要一个栈顶指针就可以了。但是队列需要两个指针：一个是 head 指针，指向队头；一个是 tail 指针，指向队尾。 你可以结合下面这幅图来理解。当 a、b、c、d 依次入队之后，队列中的 head 指针指向下标为 0 的位置，tail 指针指向下标为 4 的位置。当我们调用两次出队操作之后，队列中 head 指针指向下标为 2 的位置，tail 指针仍然指向下标为 4 的位置。 &#160; &#160;随着不停地进行入队、出队操作，head 和 tail 都会持续往后移动。当 tail 移动到最右边，即使数组中还有空闲空间，也无法继续往队列中添加数据了。这个问题该如何解决呢？ &#160; &#160;实际上，我们在出队时可以不用搬移数据。如果没有空闲空间了，我们只需要在入队时，再集中触发一次数据的搬移操作。借助这个思想，出队函数 dequeue() 保持不变，我们稍加改造一下入队函数 enqueue() 的实现，就可以轻松解决刚才的问题了。下面是具体的代码：12345678910111213141516171819// 入队操作，将 item 放入队尾public boolean enqueue(String item) &#123; // tail == n 表示队列末尾没有空间了 if (tail == n) &#123; // tail ==n &amp;&amp; head==0，表示整个队列都占满了 if (head == 0) return false; // 数据搬移 for (int i = head; i &lt; tail; ++i) &#123; items[i-head] = items[i]; &#125; // 搬移完之后重新更新 head 和 tail tail -= head; head = 0; &#125; items[tail] = item; ++tail; return true;&#125; &#160; &#160;从代码中我们看到，当队列的 tail 指针移动到数组的最右边后，如果有新的数据入队，我们可以将 head 到 tail 之间的数据，整体搬移到数组中 0 到 tail-head 的位置。 链式队列基于链表的实现，我们同样需要两个指针：head 指针和 tail 指针。它们分别指向链表的第一个结点和最后一个结点。如图所示，入队时，tail-&gt;next= new_node, tail = tail-&gt;next；出队时，head = head-&gt;next。 循环队列上面用数组来实现队列的时候，在 tail==n 时，会有数据搬移操作，这样入队操作性能就会受到影响。那有没有办法能够避免数据搬移呢？我们来看看循环队列的解决思路。循环队列，顾名思义，它长得像一个环。原本数组是有头有尾的，是一条直线。现在我们把首尾相连，扳成了一个环。我画了一张图，你可以直观地感受一下。我们可以看到，图中这个队列的大小为 8，当前 head=4，tail=7。当有一个新的元素 a 入队时，我们放入下标为 7 的位置。但这个时候，我们并不把 tail 更新为 8，而是将其在环中后移一位，到下标为 0 的位置。当再有一个元素 b 入队时，我们将 b 放入下标为 0 的位置，然后 tail 加 1 更新为 1。所以，在 a，b 依次入队之后，循环队列中的元素就变成了下面的样子：通过这样的方法，我们成功避免了数据搬移操作。看起来不难理解，但是循环队列的代码实现难度要比前面讲的非循环队列难多了。要想写出没有 bug 的循环队列的实现代码，我个人觉得，最关键的是，确定好队空和队满的判定条件。在用数组实现的非循环队列中，队满的判断条件是 tail == n，队空的判断条件是 head == tail。那针对循环队列，如何判断队空和队满呢？队列为空的判断条件仍然是 head == tail。但队列满的判断条件就稍微有点复杂了。我画了一张队列满的图，你可以看一下，试着总结一下规律。 就像我图中画的队满的情况，tail=3，head=4，n=8，所以总结一下规律就是：(3+1)%8=4。多画几张队满的图，你就会发现，队列满的判断条件是(tail+1)%n=head。你有没有发现，当队列满时，图中的 tail 指向的位置实际上是没有存储数据的。所以，循环队列会浪费一个数组的存储空间。1234567891011121314151617181920212223242526272829303132public class CircularQueue &#123; // 数组：items，数组大小：n private String[] items; private int n = 0; // head 表示队头下标，tail 表示队尾下标 private int head = 0; private int tail = 0; // 申请一个大小为 capacity 的数组 public CircularQueue(int capacity) &#123; items = new String[capacity]; n = capacity; &#125; // 入队 public boolean enqueue(String item) &#123; // 队列满了 if ((tail + 1) % n == head) return false; items[tail] = item; tail = (tail + 1) % n; return true; &#125; // 出队 public String dequeue() &#123; // 如果 head == tail 表示队列为空 if (head == tail) return null; String ret = items[head]; head = (head + 1) % n; return ret; &#125;&#125; 阻塞队列和并发队列阻塞队列 其实就是在队列基础上增加了阻塞操作。简单来说，就是在队列为空的时候，从队头取数据会被阻塞。因为此时还没有数据可取，直到队列中有了数据才能返回；如果队列已经满了，那么插入数据的操作就会被阻塞，直到队列中有空闲位置后再插入数据，然后再返回。 通过阻塞队列实现生产者-消费者模型 &#160; &#160;阻塞队列在多线程情况下，会有多个线程同时操作队列，这个时候就会存在线程安全问题，那如何实现一个线程安全的队列呢？ &#160; &#160;线程安全的队列我们叫作并发队列。最简单直接的实现方式是直接在 enqueue()、dequeue() 方法上加锁，但是锁粒度大并发度会比较低，同一时刻仅允许一个存或者取操作。实际上，基于数组的循环队列，利用 CAS 原子操作，可以实现非常高效的并发队列。这也是循环队列比链式队列应用更加广泛的原因。例如： Disruptor 。 思考线程池没有空闲线程时，新的任务请求线程资源时，线程池该如何处理？各种处理策略又是如何实现的呢？ 第一种是非阻塞的处理方式，直接拒绝任务请求； 另一种是阻塞的处理方式，将请求排队，等到有空闲线程时，取出排队的请求继续处理。那如何存储排队的请求呢？ &#160; &#160;我们希望公平地处理每个排队的请求，先进者先服务，所以队列这种数据结构很适合来存储排队请求。我们前面说过，队列有基于链表和基于数组这两种实现方式。这两种实现方式对于排队请求又有什么区别呢？ 基于链表的实现方式，可以实现一个支持无限排队的无界队列（unbounded queue），但是可能会导致过多的请求排队等待，请求处理的响应时间过长。所以，针对响应时间比较敏感的系统，基于链表实现的无限排队的线程池是不合适的。 而基于数组实现的有界队列（bounded queue），队列的大小有限，所以线程池中排队的请求超过队列大小时，接下来的请求就会被拒绝，这种方式对响应时间敏感的系统来说，就相对更加合理。不过，设置一个合理的队列大小，也是非常有讲究的。队列太大导致等待的请求太多，队列太小会导致无法充分利用系统资源、发挥最大性能。 &#160; &#160;除了前面讲到队列应用在线程池请求排队的场景之外，队列可以应用在任何有限资源池中，用于排队请求，比如数据库连接池等。实际上，对于大部分资源有限的场景，当没有空闲资源时，基本上都可以通过“队列”这种数据结构来实现请求排队。]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[数据结构与算法系列 - 04 栈]]></title>
    <url>%2F2019%2F02%2F18%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%B3%BB%E5%88%97%20-%2004%20%E6%A0%88%2F</url>
    <content type="text"><![CDATA[参考：08 | 栈：如何实现浏览器的前进和后退功能？ 从栈的操作特性上来看，栈是一种“操作受限”的线性表，只允许在一端插入和删除数据 栈既可以用数组来实现，也可以用链表来实现。用数组实现的栈，我们叫作顺序栈，用链表实现的栈，我们叫作链式栈123456789101112131415161718192021222324252627282930313233// 基于数组实现的顺序栈public class ArrayStack &#123; private String[] items; // 数组 private int count; // 栈中元素个数 private int n; // 栈的大小 // 初始化数组，申请一个大小为 n 的数组空间 public ArrayStack(int n) &#123; this.items = new String[n]; this.n = n; this.count = 0; &#125; // 入栈操作 public boolean push(String item) &#123; // 数组空间不够了，直接返回 false，入栈失败。 if (count == n) return false; // 将 item 放到下标为 count 的位置，并且 count 加一 items[count] = item; ++count; return true; &#125; // 出栈操作 public String pop() &#123; // 栈为空，则直接返回 null if (count == 0) return null; // 返回下标为 count-1 的数组元素，并且栈中元素个数 count 减一 String tmp = items[count-1]; --count; return tmp; &#125;&#125; 当某个数据集合只涉及在一端插入和删除数据，并且满足后进先出、先进后出的特性，我们就应该首选“栈”这种数据结构 栈在函数调用中的应用 &#160; &#160;操作系统给每个线程分配了一块独立的内存空间，这块内存被组织成“栈”这种结构, 用来存储函数调用时的临时变量。每进入一个函数，就会将临时变量作为一个栈帧入栈，当被调用函数执行完成，返回之后，将这个函数对应的栈帧出栈。为了让你更好地理解，我们一块来看下这段代码的执行过程。123456789101112131415int main() &#123; int a = 1; int ret = 0; int res = 0; ret = add(3, 5); res = a + ret; printf("%d", res); reuturn 0;&#125;int add(int x, int y) &#123; int sum = 0; sum = x + y; return sum;&#125; 栈在表达式求值中的应用 &#160; &#160;通过两个栈来实现的。其中一个保存操作数的栈，另一个是保存运算符的栈。我们从左向右遍历表达式，当遇到数字，我们就直接压入操作数栈；当遇到运算符，就与运算符栈的栈顶元素进行比较。 &#160; &#160;如果比运算符栈顶元素的优先级高，就将当前运算符压入栈；如果比运算符栈顶元素的优先级低或者相同，从运算符栈中取栈顶运算符，从操作数栈的栈顶取 2 个操作数，然后进行计算，再把计算完的结果压入操作数栈，继续比较。 栈在括号匹配中的应用 &#160; &#160;借助栈来检查表达式中的括号是否匹配。从左到右依次扫描字符串。当扫描到左括号时，则将其压入栈中；当扫描到右括号时，从栈顶取出一个左括号。如果能够匹配，比如“(”跟“)”匹配，“[”跟“]”匹配，“{”跟“}”匹配，则继续扫描剩下的字符串。如果扫描的过程中，遇到不能配对的右括号，或者栈中没有数据，则说明为非法格式。 &#160; &#160;当所有的括号都扫描完成之后，如果栈为空，则说明字符串为合法格式；否则，说明有未匹配的左括号，为非法格式。 注意递归代码要警惕堆栈溢出。函数调用会使用栈来保存临时变量。每调用一个函数，都会将临时变量封装为栈帧压入内存栈，等函数执行完成返回时，才出栈。系统栈或者虚拟机栈空间一般都不大。如果递归求解的数据规模很大，调用层次很深，一直压入栈，就会有堆栈溢出的风险。]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[数据结构与算法系列 - 03 链表]]></title>
    <url>%2F2019%2F02%2F14%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%B3%BB%E5%88%97%20-%2003%20%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[参考：06 | 链表（上）：如何实现LRU缓存淘汰算法? 单链表 第一个节点叫头结点（记录了链表的基地址，可以用于遍历整个链表），最后一个节点叫尾结点（特殊点在于指针域指向的是空地址null） 和数组相比： 删除、插入操作：链表只需要修改相邻节点的指针域，时间复杂度为O(1)。数组为了保持内存数据的连续性，需要大量的迁移，时间复杂度为O(n)。 查询操作：链表数据非连续性存储，需要依据指针域进行遍历，时间复杂度为O(n)。数组通过下标进行直接查询，时间复杂度为O(1)。 双向链表包含：前驱指针、后继指针、数据域，虽然浪费空间，但是支持双向遍历，操作更加方便 循环链表 和单链表不同点在于：循环链表的尾结点指针域指向的是头结点 优点：从链尾到链头比较方便，适用于环形结构的数据。如约瑟夫问题 双向循环链表 总结 &#160; &#160;链表与数组最大的区别在于，链表没有大小的限制，天然支持动态扩容。而数组的缺点是大小固定，一经声明就占用整块连续内容空间，过大可能没有连续空间使用，导致out of memory，过小则会出现不够用的情况，只能申请更多的一块空间，将原数组进行拷贝，比较耗时。 &#160; &#160;另外链表每一个结点都需要占用额外的空间用于存储指针域，所以内存占用会翻倍。而且，对链表进行频繁的插入、删除操作，还会导致频繁的内存申请和释放，容易造成内存碎片，如果是 Java 语言，就有可能会导致频繁的 GC（Garbage Collection，垃圾回收）。]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[数据结构与算法系列 - 02 复杂度分析]]></title>
    <url>%2F2019%2F02%2F14%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%B3%BB%E5%88%97%20-%2002%20%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[参考：03 | 复杂度分析（上）：如何分析、统计算法的执行效率和资源消耗？ 时间复杂度分析 大O复杂度表示法 时间复杂度的全称是渐进时间复杂度，表示代码执行时间随数据规模增长的变化趋势 复杂度分析方法 只关注循环执行次数最多的一段代码12345678int cal(int n) &#123; int sum = 0; int i = 1; for (; i &lt;= n; ++i) &#123; sum = sum + i; &#125; return sum;&#125; 其中第 2、3 行代码都是常量级的执行时间，与 n 的大小无关，所以对于复杂度并没有影响。循环执行次数最多的是第 4、5 行代码，所以这块代码要重点分析。这两行代码被执行了 n 次，所以总的时间复杂度就是 O(n)。 加法法则：总复杂度等于量级最大的那段代码的复杂度12345678910111213141516171819202122232425int cal(int n) &#123; int sum_1 = 0; int p = 1; for (; p &lt; 100; ++p) &#123; sum_1 = sum_1 + p; &#125; int sum_2 = 0; int q = 1; for (; q &lt; n; ++q) &#123; sum_2 = sum_2 + q; &#125; int sum_3 = 0; int i = 1; int j = 1; for (; i &lt;= n; ++i) &#123; j = 1; for (; j &lt;= n; ++j) &#123; sum_3 = sum_3 + i * j; &#125; &#125; return sum_1 + sum_2 + sum_3; &#125; 这个代码分为三部分，分别是求 sum_1、sum_2、sum_3。我们可以分别分析每一部分的时间复杂度，然后把它们放到一块儿，再取一个量级最大的作为整段代码的复杂度。其中sum_1是执行100次得到的结果，是一个常量的执行时间，和n的规模无关，所有复杂度为O(1)sum_2、sum_3分别为O(n)、O(n²)，T(n)=O(1)+O(n)+O(n²)。我们取其中最大的量级。所以，整段代码的时间复杂度就为 O(n²) 如果 T1(n)=O(f(n))，T2(n)=O(g(n))；那么T(n)=T1(n)+T2(n)=max(O(f(n))+O(f(n)))=O(max(f(n),g(n))) 乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积12345678910111213141516int cal(int n) &#123; int ret = 0; int i = 1; for (; i &lt; n; ++i) &#123; ret = ret + f(i); &#125; &#125; int f(int n) &#123; int sum = 0; int i = 1; for (; i &lt; n; ++i) &#123; sum = sum + i; &#125; return sum; &#125; 我们单独看 cal() 函数。假设 f() 只是一个普通的操作，那第 4～6 行的时间复杂度就是，T1(n) = O(n)。但 f() 函数本身不是一个简单的操作，它的时间复杂度是 T2(n) = O(n)，所以，整个 cal() 函数的时间复杂度就是，T(n) = T1(n) T2(n) = O(nn) = O(n²)。 如果 T1(n)=O(f(n))，T2(n)=O(g(n))；那么 T(n)=T1(n)T2(n)=O(f(n))O(g(n))=O(f(n)*g(n)) 常见复杂度量级 粗略地分为两类，多项式量级和非多项式量级。其中，非多项式量级只有两个：O(2n) 和 O(n!)。 空间复杂度 全称是渐进空间复杂度。表示算法的存储空间与数据规模之间的增长关系 123void print(int n)&#123; int[] a=new int[n];&#125; 代码中申请了一个大小为n的int类型数组变量a，，那么空间复杂度就是O(n)。我们常见的空间复杂度就是 O(1)、O(n)、O(n²)，像 O(logn)、O(nlogn) 这样的对数阶复杂度平时都用不到。 总结复杂度也叫渐进复杂度，包括时间复杂度和空间复杂度，用来分析算法执行效率与数据规模之间的增长关系，可以粗略地表示，越高阶复杂度的算法，执行效率越低。常见的复杂度并不多，从低阶到高阶有：O(1)、O(logn)、O(n)、O(nlogn)、O(n²)。 复杂度分析还有4个概念： 最坏情况时间复杂度：代码在最理想情况下执行的时间复杂度。 最好情况时间复杂度：代码在最坏情况下执行的时间复杂度。 平均时间复杂度：用代码在所有情况下执行的次数的加权平均值表示。 均摊时间复杂度：在代码执行的所有复杂度情况中绝大部分是低级别的复杂度，个别情况是高级别复杂度且发生具有时序关系时，可以将个别高级别复杂度均摊到低级别复杂度上。基本上均摊结果就等于低级别复杂度。]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[数据结构与算法系列 - 01 基础部分]]></title>
    <url>%2F2019%2F02%2F13%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%B3%BB%E5%88%97%20-%2001%20%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86%2F</url>
    <content type="text"><![CDATA[参考：数据结构：八大数据结构分类、(单向、单向循环、双向、双向循环)链表学习总结 数据结构是为算法服务的，算法要作用在特定的数据结构之上想要学习数据结构与算法，首先要掌握一个数据结构与算法中最重要的概念-复杂度分析 10 个常用数据结构：数组、链表、栈、队列、散列表、二叉树、堆、跳表、图、Trie树10个常用算法：递归、排序、二分查找、搜索、哈希算法、贪心算法、分治算法、回溯算法、动态规划、字符串匹配算法 数组 介绍： 可以在内存中连续分配的数据结构 元素通过下标进行访问 优点： 按照索引查询速度快 按照索引遍历方便 缺点： 元素删除、新增操作慢，需要移动其他元素 只能存储单一类型的元素 容量在初始化时确定下来，无法扩容 适用场景： 查询频繁，删除、新增操作少，对存储空间要求不大 栈 介绍： 一种特殊的线性表，只能在线性表的一端操作 栈顶允许操作，栈底不能操作 特点先进后出 栈顶放入元素成为入栈（PUSH），取出元素称为出栈（POP） 优点： 缺点： 适用场景： 递归等场景 链表 介绍： 物理存储单元上非连续、非顺序的存储结构 数据元素的逻辑顺序是通过链表指针实现的 每个元素包含两个节点：一个存储元素的数据域，一个指向下一个节点的指针域 根据指针的指向，可以分为：单链表、双向链表、循环链表 优点： 不需要初始化，可以随意添加、删除元素 添加、删除只需要修改改变前后两个节点的指针域指向地址即可，所有添加、删除操作速度快 缺点： 因含有指针域，所以占用空间大 查询元素比较耗时，需要遍历整个链表 适用场景： 数据量小，但是需要频繁添加、删除的场景 队列 介绍： 一种线性表 可以在一端添加元素，另一端取出元素，即先进先出 优点： 缺点： 适用场景： 阻塞队列 图 介绍：&#160; &#160;图是由结点的有穷集合V和边的集合E组成。其中，为了与树形结构加以区别，在图结构中常常将结点称为顶点，边是顶点的有序偶对，若两个顶点之间存在一条边，就表示这两个顶点具有相邻关系。按照顶点指向的方向可分为无向图和有向图：&#160; &#160;图是一种比较复杂的数据结构，在存储数据上有着比较复杂和高效的算法，分别有邻接矩阵 、邻接表、十字链表、邻接多重表、边集数组等存储结构 树 介绍： 由n(n&gt;=1)个元素组成的具有层次关系的集合 每个节点有零或者多个子节点 没有父节点的节点为根节点 每一个非根节点有且只有一个根节点 除了根节点，每个子节点可以分为多个不相交的子树 堆 介绍：堆的定义如下：n个元素的序列{k1,k2,ki,…,kn}当且仅当满足下关系时，称之为堆 比较特殊的数据结构，可以被看做一棵树的数组对象 堆中某个节点的值总是不大于或不小于其父节点的值 堆总是一棵完全二叉树 根节点最大的堆叫做最大堆或大根堆，根节点最小的堆叫做最小堆或小根堆。常见的堆有二叉堆、斐波那契堆等 满足(ki &lt;= k2i,ki &lt;= k2i+1)称为小顶堆 满足(ki &gt;= k2i,ki &gt;= k2i+1)称为大顶堆 散列表 介绍：&#160; &#160;散列表，也叫哈希表，是根据关键码和值 (key和value) 直接进行访问的数据结构，通过key和value来映射到集合中的一个位置，这样就可以很快找到集合中的对应元素。记录的存储位置=f(key)&#160; &#160;这里的对应关系 f 成为散列函数，又称为哈希 (hash函数)，而散列表就是把Key通过一个固定的算法函数既所谓的哈希函数转换成一个整型数字，然后就将该数字对数组长度进行取余，取余结果就当作数组的下标，将value存储在以该数字为下标的数组空间里，这种存储空间可以充分利用数组的查找优势来查找元素，所以查找的速度很快。&#160; &#160;哈希表在应用中也是比较常见的，就如Java中有些集合类就是借鉴了哈希原理构造的，例如HashMap，HashTable等，利用hash表的优势，对于集合的查找元素时非常方便的，然而，因为哈希表是基于数组衍生的数据结构，在添加删除元素方面是比较慢的，所以很多时候需要用到一种数组链表来做，也就是拉链法。拉链法是数组结合链表的一种结构，较早前的hashMap底层的存储就是采用这种结构，直到jdk1.8之后才换成了数组加红黑树的结构，其示例图如下：&#160; &#160;从图中可以看出，左边很明显是个数组，数组的每个成员包括一个指针，指向一个链表的头，当然这个链表可能为空，也可能元素很多。我们根据元素的一些特征把元素分配到不同的链表中去，也是根据这些特征，找到正确的链表，再从链表中找出这个元素。哈希表的应用场景很多，当然也有很多问题要考虑，比如哈希冲突的问题，如果处理的不好会浪费大量的时间，导致应用崩溃。 优点： 查找速度快 缺点： 适用场景： 学习书籍推荐]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[学习JVM]]></title>
    <url>%2F2019%2F01%2F14%2F%E5%AD%A6%E4%B9%A0JVM%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F01%2F14%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
